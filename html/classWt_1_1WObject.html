<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boogle Home: Wt::WObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Boogle Home
   &#160;<span id="projectnumber">VirtualAssistant</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceWt.html">Wt</a></li><li class="navelem"><a class="el" href="classWt_1_1WObject.html">WObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classWt_1_1WObject-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wt::WObject Class Reference<div class="ingroups"><a class="el" href="group__signalslot.html">Signal/slot system</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A base class for objects that participate in the signal/slot system.  
 <a href="classWt_1_1WObject.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="WObject_8h_source.html">Wt/WObject.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Wt::WObject:</div>
<div class="dyncontent">
<div class="center"><img src="classWt_1_1WObject__inherit__graph.png" border="0" usemap="#Wt_1_1WObject_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Wt::WObject:</div>
<div class="dyncontent">
<div class="center"><img src="classWt_1_1WObject__coll__graph.png" border="0" usemap="#Wt_1_1WObject_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWt_1_1WObject_1_1FormData.html">FormData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aec904644d278b09d3f7e568fd2efd400"><td class="memItemLeft" align="right" valign="top"><a id="aec904644d278b09d3f7e568fd2efd400"></a>
typedef void(WObject::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a>) ()</td></tr>
<tr class="memdesc:aec904644d278b09d3f7e568fd2efd400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a WObject method without arguments. <br /></td></tr>
<tr class="separator:aec904644d278b09d3f7e568fd2efd400"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab70a7353c304f8594f6491d999625a21"><td class="memItemLeft" align="right" valign="top"><a id="ab70a7353c304f8594f6491d999625a21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>WObject</b> (const <a class="el" href="classWt_1_1WObject.html">WObject</a> &amp;)=delete</td></tr>
<tr class="separator:ab70a7353c304f8594f6491d999625a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3844d4dc5076b49e7414f04f90837f97"><td class="memItemLeft" align="right" valign="top"><a id="a3844d4dc5076b49e7414f04f90837f97"></a>
<a class="el" href="classWt_1_1WObject.html">WObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classWt_1_1WObject.html">WObject</a> &amp;)=delete</td></tr>
<tr class="separator:a3844d4dc5076b49e7414f04f90837f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de0f0baf35f42aa4e77a90d427f2e11"><td class="memItemLeft" align="right" valign="top"><a id="a3de0f0baf35f42aa4e77a90d427f2e11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a3de0f0baf35f42aa4e77a90d427f2e11">addChild</a> (std::unique_ptr&lt; <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt; child)</td></tr>
<tr class="memdesc:a3de0f0baf35f42aa4e77a90d427f2e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a> whose lifetime is determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. <br /></td></tr>
<tr class="separator:a3de0f0baf35f42aa4e77a90d427f2e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73777218b9a77b674e15a62d14eab734"><td class="memTemplParams" colspan="2">template&lt;typename Child &gt; </td></tr>
<tr class="memitem:a73777218b9a77b674e15a62d14eab734"><td class="memTemplItemLeft" align="right" valign="top">Child *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a73777218b9a77b674e15a62d14eab734">addChild</a> (std::unique_ptr&lt; Child &gt; child)</td></tr>
<tr class="memdesc:a73777218b9a77b674e15a62d14eab734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, returning a raw pointer.  <a href="classWt_1_1WObject.html#a73777218b9a77b674e15a62d14eab734">More...</a><br /></td></tr>
<tr class="separator:a73777218b9a77b674e15a62d14eab734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d60618c6ca687226a5f1bbf1be6dc4"><td class="memItemLeft" align="right" valign="top"><a id="ad1d60618c6ca687226a5f1bbf1be6dc4"></a>
std::unique_ptr&lt; <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#ad1d60618c6ca687226a5f1bbf1be6dc4">removeChild</a> (<a class="el" href="classWt_1_1WObject.html">WObject</a> *child)</td></tr>
<tr class="memdesc:ad1d60618c6ca687226a5f1bbf1be6dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. <br /></td></tr>
<tr class="separator:ad1d60618c6ca687226a5f1bbf1be6dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34743ebfe5d0063495964f33286523d5"><td class="memTemplParams" colspan="2">template&lt;typename Child &gt; </td></tr>
<tr class="memitem:a34743ebfe5d0063495964f33286523d5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; Child *, <a class="el" href="classWt_1_1WObject.html">WObject</a> * &gt;::value &amp;&amp;!std::is_same&lt; Child, <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt;::value, std::unique_ptr&lt; Child &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a34743ebfe5d0063495964f33286523d5">removeChild</a> (Child *child)</td></tr>
<tr class="memdesc:a34743ebfe5d0063495964f33286523d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>.  <a href="classWt_1_1WObject.html#a34743ebfe5d0063495964f33286523d5">More...</a><br /></td></tr>
<tr class="separator:a34743ebfe5d0063495964f33286523d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07106c614644fcccf5e3d8543ef9cab0"><td class="memItemLeft" align="right" valign="top"><a id="a07106c614644fcccf5e3d8543ef9cab0"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>rawUniqueId</b> () const</td></tr>
<tr class="separator:a07106c614644fcccf5e3d8543ef9cab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888964c358571b929a4a2b59a68e3213"><td class="memItemLeft" align="right" valign="top"><a id="a888964c358571b929a4a2b59a68e3213"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>uniqueId</b> () const</td></tr>
<tr class="separator:a888964c358571b929a4a2b59a68e3213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34b0c9ec343cf467f8b237d3256792"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a9f34b0c9ec343cf467f8b237d3256792">id</a> () const</td></tr>
<tr class="memdesc:a9f34b0c9ec343cf467f8b237d3256792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (unique) identifier for this object.  <a href="classWt_1_1WObject.html#a9f34b0c9ec343cf467f8b237d3256792">More...</a><br /></td></tr>
<tr class="separator:a9f34b0c9ec343cf467f8b237d3256792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875fda02eff6260ab665647f7215e262"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a875fda02eff6260ab665647f7215e262">setObjectName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a875fda02eff6260ab665647f7215e262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an object name.  <a href="classWt_1_1WObject.html#a875fda02eff6260ab665647f7215e262">More...</a><br /></td></tr>
<tr class="separator:a875fda02eff6260ab665647f7215e262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aedaccd24488c182912782de70ce2d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a73aedaccd24488c182912782de70ce2d">objectName</a> () const</td></tr>
<tr class="memdesc:a73aedaccd24488c182912782de70ce2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object name.  <a href="classWt_1_1WObject.html#a73aedaccd24488c182912782de70ce2d">More...</a><br /></td></tr>
<tr class="separator:a73aedaccd24488c182912782de70ce2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d8b00edc79b7a60d41d7c088f50436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436">resetLearnedSlots</a> ()</td></tr>
<tr class="memdesc:a92d8b00edc79b7a60d41d7c088f50436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets learned stateless slot implementations.  <a href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436">More...</a><br /></td></tr>
<tr class="separator:a92d8b00edc79b7a60d41d7c088f50436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698">resetLearnedSlot</a> (void(T::*method)())</td></tr>
<tr class="memdesc:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a learned stateless slot implementation.  <a href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698">More...</a><br /></td></tr>
<tr class="separator:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless</a> (void(T::*method)())</td></tr>
<tr class="memdesc:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a slot to be stateless and learn client-side behaviour on first invocation.  <a href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">More...</a><br /></td></tr>
<tr class="separator:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf46fd1437f07150a9dd95bd95c266d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7bf46fd1437f07150a9dd95bd95c266d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a7bf46fd1437f07150a9dd95bd95c266d">implementStateless</a> (void(T::*method)(), void(T::*undoMethod)())</td></tr>
<tr class="memdesc:a7bf46fd1437f07150a9dd95bd95c266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a slot to be stateless and learn client-side behaviour in advance.  <a href="classWt_1_1WObject.html#a7bf46fd1437f07150a9dd95bd95c266d">More...</a><br /></td></tr>
<tr class="separator:a7bf46fd1437f07150a9dd95bd95c266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dde4ce1e833a9966709daf3c0dedc9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a6dde4ce1e833a9966709daf3c0dedc9f">isNotStateless</a> ()</td></tr>
<tr class="memdesc:a6dde4ce1e833a9966709daf3c0dedc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the current function as not stateless.  <a href="classWt_1_1WObject.html#a6dde4ce1e833a9966709daf3c0dedc9f">More...</a><br /></td></tr>
<tr class="separator:a6dde4ce1e833a9966709daf3c0dedc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214deee5d7324b9afd4ce44534daa782"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a214deee5d7324b9afd4ce44534daa782"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a214deee5d7324b9afd4ce44534daa782">implementJavaScript</a> (void(T::*method)(), const std::string &amp;jsCode)</td></tr>
<tr class="memdesc:a214deee5d7324b9afd4ce44534daa782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a JavaScript implementation for a method.  <a href="classWt_1_1WObject.html#a214deee5d7324b9afd4ce44534daa782">More...</a><br /></td></tr>
<tr class="separator:a214deee5d7324b9afd4ce44534daa782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e3176f9f1f814a13420d829b07cc6c"><td class="memItemLeft" align="right" valign="top"><a id="af0e3176f9f1f814a13420d829b07cc6c"></a>
<a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>isStateless</b> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method) const</td></tr>
<tr class="separator:af0e3176f9f1f814a13420d829b07cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classWt_1_1Core_1_1observable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classWt_1_1Core_1_1observable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classWt_1_1Core_1_1observable.html">Wt::Core::observable</a></td></tr>
<tr class="memitem:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top"><a id="ac18aee9da79a11ad8492ed5e95ed52e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#ac18aee9da79a11ad8492ed5e95ed52e4">observable</a> () noexcept</td></tr>
<tr class="memdesc:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#aaff32cdbd6cd167b3e384f0d7ee7d0b8">~observable</a> ()</td></tr>
<tr class="memdesc:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classWt_1_1Core_1_1observable.html#aaff32cdbd6cd167b3e384f0d7ee7d0b8">More...</a><br /></td></tr>
<tr class="separator:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625f1708625699d556d00c8d96a4bb71 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top"><a id="a625f1708625699d556d00c8d96a4bb71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>observable</b> (const <a class="el" href="classWt_1_1Core_1_1observable.html">observable</a> &amp;)=delete</td></tr>
<tr class="separator:a625f1708625699d556d00c8d96a4bb71 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597c081875ade0dec5bb6741c1c05e2c inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top"><a id="a597c081875ade0dec5bb6741c1c05e2c"></a>
<a class="el" href="classWt_1_1Core_1_1observable.html">observable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classWt_1_1Core_1_1observable.html">observable</a> &amp;)=delete</td></tr>
<tr class="separator:a597c081875ade0dec5bb6741c1c05e2c inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720fc263d40a60092b44302584810ea2 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top"><a id="a720fc263d40a60092b44302584810ea2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>observable</b> (<a class="el" href="classWt_1_1Core_1_1observable.html">observable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a720fc263d40a60092b44302584810ea2 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dae2f6e52ebc8bc3a130dfdd0ea2401 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top"><a id="a6dae2f6e52ebc8bc3a130dfdd0ea2401"></a>
<a class="el" href="classWt_1_1Core_1_1observable.html">observable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classWt_1_1Core_1_1observable.html">observable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a6dae2f6e52ebc8bc3a130dfdd0ea2401 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139d2f6b87228ddbf97857c9ca81e89 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2"><a id="ad139d2f6b87228ddbf97857c9ca81e89"></a>
template&lt;typename... Args, typename ClassType &gt; </td></tr>
<tr class="memitem:ad139d2f6b87228ddbf97857c9ca81e89 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bindSafe</b> (void(ClassType::*f)(Args...)) noexcept -&gt; std::function&lt; void(Args...)&gt;</td></tr>
<tr class="separator:ad139d2f6b87228ddbf97857c9ca81e89 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba032e0de28f877141614dc81fb67d3 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2"><a id="a0ba032e0de28f877141614dc81fb67d3"></a>
template&lt;typename... Args, typename ClassType &gt; </td></tr>
<tr class="memitem:a0ba032e0de28f877141614dc81fb67d3 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bindSafe</b> (void(ClassType::*f)(Args...) const) const noexcept -&gt; std::function&lt; void(Args...)&gt;</td></tr>
<tr class="separator:a0ba032e0de28f877141614dc81fb67d3 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64503740d940b1a41993161c05a6f797 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2"><a id="a64503740d940b1a41993161c05a6f797"></a>
template&lt;typename FirstArg , typename... Args, class F &gt; </td></tr>
<tr class="memitem:a64503740d940b1a41993161c05a6f797 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bindSafe</b> (F &amp;&amp;f) const noexcept -&gt; std::function&lt; decltype(f(std::declval&lt; FirstArg &gt;(), std::declval&lt; Args &gt;()...))(FirstArg, Args...)&gt;</td></tr>
<tr class="separator:a64503740d940b1a41993161c05a6f797 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434e48bbd9aa66939dff686ff4b1f153 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2"><a id="a434e48bbd9aa66939dff686ff4b1f153"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a434e48bbd9aa66939dff686ff4b1f153 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bindSafe</b> (F &amp;&amp;f) const noexcept -&gt; decltype(bindSafe(&amp;std::remove_reference&lt; F &gt;::type::operator()))</td></tr>
<tr class="separator:a434e48bbd9aa66939dff686ff4b1f153 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7823bd7c35f55a2d04bdaaee288c9b4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2"><a id="ac7823bd7c35f55a2d04bdaaee288c9b4"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac7823bd7c35f55a2d04bdaaee288c9b4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(Args...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bindSafe</b> (const std::function&lt; void(Args...)&gt; &amp;f) const noexcept</td></tr>
<tr class="separator:ac7823bd7c35f55a2d04bdaaee288c9b4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af835d3dba7b5d043709b14a1b042ff2e"><td class="memItemLeft" align="right" valign="top"><a id="af835d3dba7b5d043709b14a1b042ff2e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>seedId</b> (unsigned <a class="el" href="classWt_1_1WObject.html#a9f34b0c9ec343cf467f8b237d3256792">id</a>)</td></tr>
<tr class="separator:af835d3dba7b5d043709b14a1b042ff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa996079298424b7d71388367a75f704e"><td class="memItemLeft" align="right" valign="top"><a id="aa996079298424b7d71388367a75f704e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>signalConnectionsChanged</b> ()</td></tr>
<tr class="separator:aa996079298424b7d71388367a75f704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98211733311178e0440b6f2bbe98149c"><td class="memItemLeft" align="right" valign="top"><a id="a98211733311178e0440b6f2bbe98149c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setFormData</b> (const <a class="el" href="structWt_1_1WObject_1_1FormData.html">FormData</a> &amp;formData)</td></tr>
<tr class="separator:a98211733311178e0440b6f2bbe98149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290e1873497a04eaa5b32fa745d952fb"><td class="memItemLeft" align="right" valign="top"><a id="a290e1873497a04eaa5b32fa745d952fb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setRequestTooLarge</b> (::int64_t size)</td></tr>
<tr class="separator:a290e1873497a04eaa5b32fa745d952fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed50331d6abf7c19628b3140daa9b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#adbed50331d6abf7c19628b3140daa9b4">getStateless</a> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method)</td></tr>
<tr class="memdesc:adbed50331d6abf7c19628b3140daa9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">On-demand stateless slot implementation.  <a href="classWt_1_1WObject.html#adbed50331d6abf7c19628b3140daa9b4">More...</a><br /></td></tr>
<tr class="separator:adbed50331d6abf7c19628b3140daa9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaa0e872146a93a43416b1eee32b9f686"><td class="memItemLeft" align="right" valign="top"><a id="aaa0e872146a93a43416b1eee32b9f686"></a>
<a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>implementPrelearn</b> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method, <a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> undoMethod)</td></tr>
<tr class="separator:aaa0e872146a93a43416b1eee32b9f686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ac994c273a52967b54cdf7aed1811a"><td class="memItemLeft" align="right" valign="top"><a id="a31ac994c273a52967b54cdf7aed1811a"></a>
<a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>implementPrelearned</b> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method, const std::string &amp;jsCode)</td></tr>
<tr class="separator:a31ac994c273a52967b54cdf7aed1811a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b76423a75f0ba37f45784e469a16859"><td class="memItemLeft" align="right" valign="top"><a id="a0b76423a75f0ba37f45784e469a16859"></a>
<a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>implementAutolearn</b> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method)</td></tr>
<tr class="separator:a0b76423a75f0ba37f45784e469a16859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140ef7ec17aae0fc20863d863e5584e6"><td class="memItemLeft" align="right" valign="top"><a id="a140ef7ec17aae0fc20863d863e5584e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetLearnedSlot</b> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method)</td></tr>
<tr class="separator:a140ef7ec17aae0fc20863d863e5584e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a65d9b069f4260eae79cf85e4e5e17d9a"><td class="memItemLeft" align="right" valign="top"><a id="a65d9b069f4260eae79cf85e4e5e17d9a"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>statelessSlots_</b></td></tr>
<tr class="separator:a65d9b069f4260eae79cf85e4e5e17d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0a36fd9824cb59e06a80dfd400b27"><td class="memItemLeft" align="right" valign="top"><a id="aa3c0a36fd9824cb59e06a80dfd400b27"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>children_</b></td></tr>
<tr class="separator:aa3c0a36fd9824cb59e06a80dfd400b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b89dad01f5f3f55e2c389c796c53f8"><td class="memItemLeft" align="right" valign="top"><a id="a58b89dad01f5f3f55e2c389c796c53f8"></a>
const unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>id_</b></td></tr>
<tr class="separator:a58b89dad01f5f3f55e2c389c796c53f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539d8a1792fef27d2ea8acec034dd12"><td class="memItemLeft" align="right" valign="top"><a id="aa539d8a1792fef27d2ea8acec034dd12"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name_</b></td></tr>
<tr class="separator:aa539d8a1792fef27d2ea8acec034dd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a4d5596be28ff5f7418e59b4040793fdd"><td class="memItemLeft" align="right" valign="top"><a id="a4d5596be28ff5f7418e59b4040793fdd"></a>
static unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>nextObjId_</b></td></tr>
<tr class="separator:a4d5596be28ff5f7418e59b4040793fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a51f71f26be5bfce179266fdecad9f91d"><td class="memItemLeft" align="right" valign="top"><a id="a51f71f26be5bfce179266fdecad9f91d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>EventSignalBase</b></td></tr>
<tr class="separator:a51f71f26be5bfce179266fdecad9f91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f159dd904f669563320a185598a167"><td class="memItemLeft" align="right" valign="top"><a id="a59f159dd904f669563320a185598a167"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>WApplication</b></td></tr>
<tr class="separator:a59f159dd904f669563320a185598a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8248f10e62aee707eabe43458855d835"><td class="memItemLeft" align="right" valign="top"><a id="a8248f10e62aee707eabe43458855d835"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>WebSession</b></td></tr>
<tr class="separator:a8248f10e62aee707eabe43458855d835"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A base class for objects that participate in the signal/slot system. </p>
<p>The main feature offered by WObject is automated object life-time tracking when involved in signal/slot connections. Connections between signals and slots of WObject instances implement a type-safe event callback system. For example, one can simply connect() the <a class="el" href="classWt_1_1WInteractWidget.html#af6cb297f8593e6884de66d23ea69d49c" title="Event signal emitted when the primary mouse button was clicked on this widget.">WInteractWidget::clicked()</a> signal of a <a class="el" href="classWt_1_1WPushButton.html" title="A widget that represents a push button.">WPushButton</a> to the <a class="el" href="classWt_1_1WApplication.html#a5231d54ed34982f4366058eb6440c8f7" title="Quits the application.">WApplication::quit()</a> method, to exit the application when the button is clicked:</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Wt::WInteractWidget&gt; sender{<span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html">Wt::WText</a>(<span class="stringliteral">&quot;Quit.&quot;</span>)};</div>
<div class="line"><a class="code" href="classWt_1_1WApplication.html">Wt::WApplication</a> *app = <a class="code" href="classWt_1_1WApplication.html#a27690e10fb1dffef9b688b5a6ecf26b0">Wt::WApplication::instance</a>();</div>
<div class="line">sender-&gt;clicked().connect(app, &amp;<a class="code" href="classWt_1_1WApplication.html#a5231d54ed34982f4366058eb6440c8f7">Wt::WApplication::quit</a>);</div>
</div><!-- fragment --><p>Wt's signals may also propagate arguments to slots. For example, the same clicked() signal provides event details in a <a class="el" href="classWt_1_1WMouseEvent.html" title="A class providing details for a mouse event.">WMouseEvent</a> details class, and these details may be received in the slot: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyClass()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classWt_1_1WText.html">Wt::WText</a> *text = addWidget(std::make_unique&lt;Wt::WText&gt;(<span class="stringliteral">&quot;Click here&quot;</span>));</div>
<div class="line">    text-&gt;clicked().connect(<span class="keyword">this</span>, &amp;MyClass::handleClick);</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> handleClick(<span class="keyword">const</span> <a class="code" href="classWt_1_1WMouseEvent.html">Wt::WMouseEvent</a>&amp; event) {</div>
<div class="line">    <span class="keywordflow">if</span> (event.modifiers().test(Wt::KeyboardModifier::Shift)) {</div>
<div class="line">      ...</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> As the example illustrates, slots are ordinary WObject methods.</p>
<p>In conjunction with <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a>, WObject also facilitates learning of client-side event handling (in JavaScript) through invocation of the slot method. This is only possible when the slot behaviour is stateless, i.e. independent of any application state, and can be specified using the <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> methods.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a>, <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a73777218b9a77b674e15a62d14eab734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73777218b9a77b674e15a62d14eab734">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Child &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Child* Wt::WObject::addChild </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Child &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, returning a raw pointer. </p>
<p>This is implemented as:</p>
<div class="fragment"><div class="line">Child *result = child.get();</div>
<div class="line"><a class="code" href="classWt_1_1WObject.html#a3de0f0baf35f42aa4e77a90d427f2e11">addChild</a>(std::unique_ptr&lt;WObject&gt;(std::move(child)));</div>
<div class="line"><span class="keywordflow">return</span> result;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adbed50331d6abf7c19628b3140daa9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbed50331d6abf7c19628b3140daa9b4">&#9670;&nbsp;</a></span>getStateless()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a>* Wt::WObject::getStateless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On-demand stateless slot implementation. </p>
<p>This method returns a stateless slot implementation for the given <code>method</code>. To avoid the cost of declaring methods to be stateless when they are not used, you may reimplement this method to provide a stateless implementation for a method only when the method is involved in a slot connection.</p>
<p>Use <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> to provide a stateless implementation of the given <code>method</code>, or return the base class implementation otherwise. </p>

<p>Reimplemented in <a class="el" href="classWt_1_1WWidget.html#af0055d333414c99aee674e13da95f89b">Wt::WWidget</a>, <a class="el" href="classWt_1_1WWebWidget.html#a603ed3e92421dab3c96dda05afa47513">Wt::WWebWidget</a>, and <a class="el" href="classWt_1_1WAbstractToggleButton.html#adf52bd04a8c10ff6dda2db224e25cb71">Wt::WAbstractToggleButton</a>.</p>

</div>
</div>
<a id="a9f34b0c9ec343cf467f8b237d3256792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f34b0c9ec343cf467f8b237d3256792">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string Wt::WObject::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (unique) identifier for this object. </p>
<p>For a WWidget, this corresponds to the id of the DOM element that represents the widget. This is not entirely unique, since a <a class="el" href="classWt_1_1WCompositeWidget.html">composite widget</a> shares the same id as its implementation.</p>
<p>By default, the id is auto-generated, unless a custom id is set for a widget using <a class="el" href="classWt_1_1WWidget.html#a93ff9d1ca04e733cd54cd40a06775f7e" title="Sets the CSS Id.">WWidget::setId()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WWidget.html#a83a186d2feacfbfbdb5b54f4cefc6735" title="Returns a JavaScript expression to the corresponding DOM node.">WWidget::jsRef()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1WWebWidget.html#ab438c51f9184d0ed37d01b15f07355d6">Wt::WWebWidget</a>, <a class="el" href="classWt_1_1WTableRow.html#ae0097a7de92acdb677f3b98e0b993f93">Wt::WTableRow</a>, <a class="el" href="classWt_1_1WButtonGroup.html#a2f1b5269d9dae69bdc78aaa8ede36e1b">Wt::WButtonGroup</a>, <a class="el" href="classWt_1_1WTableColumn.html#a84baf2a0d96367fe0d6c1a0ca6e49ce9">Wt::WTableColumn</a>, <a class="el" href="classWt_1_1WCompositeWidget.html#a6e7fc16162314016e109b771ce476d59">Wt::WCompositeWidget</a>, and <a class="el" href="classWt_1_1StdWidgetItemImpl.html#ad44ff4c23ffc82d11e465e447dacb79d">Wt::StdWidgetItemImpl</a>.</p>

</div>
</div>
<a id="a214deee5d7324b9afd4ce44534daa782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214deee5d7324b9afd4ce44534daa782">&#9670;&nbsp;</a></span>implementJavaScript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> * Wt::WObject::implementJavaScript </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jsCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a JavaScript implementation for a method. </p>
<p>This method sets the JavaScript implementation for a method. As a result, if JavaScript is available, the JavaScript version will be used on the client side and the visual effect of the C++ implementation will be ignored.</p>
<p>This is very similar to an auto-learned stateless slot, but here the learning is avoided by directly setting the JavaScript implementation.</p>
<p>The <code>jsCode</code> should be one or more valid JavaScript statements.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless(void (T::*method)())</a> </dd></dl>

</div>
</div>
<a id="adaa163b9e92933f3b2ff4ec58e2734c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa163b9e92933f3b2ff4ec58e2734c6">&#9670;&nbsp;</a></span>implementStateless() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> * Wt::WObject::implementStateless </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a slot to be stateless and learn client-side behaviour on first invocation. </p>
<p>Indicate that the given slot is stateless, and meets the requirement that the slot's code does not depend on any state of the object, but performs the same visual effect regardless of any state, or at least until <a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a> is called.</p>
<p>When this slot is connected to an <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a> (such as those exposed by <a class="el" href="classWt_1_1WInteractWidget.html" title="An abstract widget that can receive user-interface interaction.">WInteractWidget</a> and <a class="el" href="classWt_1_1WFormWidget.html" title="An abstract widget that corresponds to an HTML form element.">WFormWidget</a>), the Wt library may decide to cache the visual effect of this slot in JavaScript code at client-side: this effect will be learned automatically at the first invocation. This has no consequences for the normal event handling, since the slot implementation is still executed in response to any event notification. Therefore, it is merely an optimization of the latency for the visual effect, but it does not change the behaviour of the application.</p>
<p>When for some reason the visual effect does change, one may use <a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a> or <a class="el" href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436" title="Resets learned stateless slot implementations.">resetLearnedSlots()</a> to flush the existing cached visual effect, forcing the library to relearn it.</p>
<p>It is crucial that this function be applied first to a slot that is intended to be stateless before any EventSignal connects to that slot. Otherwise, the connecting EventSignal cannot find the stateless slot implementation for the intended slot, and the statement will have no effect for that connection.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a>, <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a> </dd></dl>

</div>
</div>
<a id="a7bf46fd1437f07150a9dd95bd95c266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf46fd1437f07150a9dd95bd95c266d">&#9670;&nbsp;</a></span>implementStateless() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WStatelessSlot.html">WStatelessSlot</a> * Wt::WObject::implementStateless </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>undoMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a slot to be stateless and learn client-side behaviour in advance. </p>
<p>This method has the same effect as <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless(void (T::*method)())</a>, but learns the visual effect of the slot before the first invocation of the event.</p>
<p>To learn the visual effect, the library will simulate the event and record the visual effect. To restore the application state, it will call the undoMethod which must restore the effect of method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless(void (T::*method)())</a> </dd></dl>

</div>
</div>
<a id="a6dde4ce1e833a9966709daf3c0dedc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dde4ce1e833a9966709daf3c0dedc9f">&#9670;&nbsp;</a></span>isNotStateless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WObject::isNotStateless </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the current function as not stateless. </p>
<p>This may be useful if your current function is manipulating the UI in a way that is not stateless (i.e. does depend on some state), but which happens to be called from within a function that is marked stateless (such as <a class="el" href="classWt_1_1WWidget.html#a66bdda41220267a8c7ff9865996e2675" title="Hides or shows the widget.">WWidget::setHidden()</a>). This will reject stateless slot pre-learning in this case, reverting to plain server-side dynamic UI updates. </p>

</div>
</div>
<a id="a73aedaccd24488c182912782de70ce2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aedaccd24488c182912782de70ce2d">&#9670;&nbsp;</a></span>objectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Wt::WObject::objectName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object name. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#a875fda02eff6260ab665647f7215e262" title="Sets an object name.">setObjectName()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1WCompositeWidget.html#a379aaf81ec17f4f17befd1979df17ab1">Wt::WCompositeWidget</a>.</p>

</div>
</div>
<a id="a34743ebfe5d0063495964f33286523d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34743ebfe5d0063495964f33286523d5">&#9670;&nbsp;</a></span>removeChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Child &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;Child*,<a class="el" href="classWt_1_1WObject.html">WObject</a>*&gt;::value &amp;&amp; !std::is_same&lt;Child,<a class="el" href="classWt_1_1WObject.html">WObject</a>&gt;::value, std::unique_ptr&lt;Child&gt; &gt;::type Wt::WObject::removeChild </td>
          <td>(</td>
          <td class="paramtype">Child *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. </p>
<p>This is an overload that automatically casts the returned value to a unique_ptr&lt;Child&gt; for convenience</p>
<p>This is implemented as: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> std::unique_ptr&lt;Child&gt;(<span class="keyword">static_cast&lt;</span>Child*<span class="keyword">&gt;</span>(<a class="code" href="classWt_1_1WObject.html#ad1d60618c6ca687226a5f1bbf1be6dc4">removeChild</a>(<span class="keyword">static_cast&lt;</span>WObject*<span class="keyword">&gt;</span>(child)).release()));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5c7dcd5a60c88e5b36f0c8e0f9117698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7dcd5a60c88e5b36f0c8e0f9117698">&#9670;&nbsp;</a></span>resetLearnedSlot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WObject::resetLearnedSlot </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a learned stateless slot implementation. </p>
<p>Clears the stateless implementation for the given slot that was declared to be implemented with a stateless implementation.</p>
<p>When something has changed that breaks the contract of a stateless slot to always have the same effect, you may call this method to force the application to discard the current implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> </dd></dl>

</div>
</div>
<a id="a92d8b00edc79b7a60d41d7c088f50436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d8b00edc79b7a60d41d7c088f50436">&#9670;&nbsp;</a></span>resetLearnedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WObject::resetLearnedSlots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets learned stateless slot implementations. </p>
<p>Clears the stateless implementation for all slots declared to be implemented with a stateless implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a>, <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> </dd></dl>

</div>
</div>
<a id="a875fda02eff6260ab665647f7215e262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875fda02eff6260ab665647f7215e262">&#9670;&nbsp;</a></span>setObjectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wt::WObject::setObjectName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an object name. </p>
<p>The object name can be used to easily identify a type of object in the DOM, and does not need to be unique. It will usually reflect the widget type or role.</p>
<p>If a <a class="el" href="classWt_1_1WWidget.html" title="The abstract base class for a user-interface component.">WWidget</a> has an object name, the object name is reflected in the <code>data-object-name</code> attribute. You can use this to find widgets in JavaScript (e.g. for automated testing) using:</p>
<div class="fragment"><div class="line">document.querySelector(<span class="stringliteral">&#39;*[data-object-name=&quot;yourObjectNameHere&quot;]&#39;</span>)</div>
</div><!-- fragment --><p>The default object name is empty (no object name). </p>

<p>Reimplemented in <a class="el" href="classWt_1_1WWebWidget.html#a8a90ac0a5b963994ee0e5ff35213b276">Wt::WWebWidget</a>, and <a class="el" href="classWt_1_1WCompositeWidget.html#a0f46cc7bc8e0aa368837dcc138303c76">Wt::WCompositeWidget</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>wt-4.8.2/src/Wt/<a class="el" href="WObject_8h_source.html">WObject.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassWt_1_1WObject_html_ad1d60618c6ca687226a5f1bbf1be6dc4"><div class="ttname"><a href="classWt_1_1WObject.html#ad1d60618c6ca687226a5f1bbf1be6dc4">Wt::WObject::removeChild</a></div><div class="ttdeci">std::unique_ptr&lt; WObject &gt; removeChild(WObject *child)</div><div class="ttdoc">Remove a child WObject, so its lifetime is no longer determined by this WObject.</div></div>
<div class="ttc" id="aclassWt_1_1WContainerWidget_html"><div class="ttname"><a href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a></div><div class="ttdoc">A widget that holds and manages child widgets.</div><div class="ttdef"><b>Definition:</b> WContainerWidget.h:134</div></div>
<div class="ttc" id="aclassWt_1_1WObject_html_a3de0f0baf35f42aa4e77a90d427f2e11"><div class="ttname"><a href="classWt_1_1WObject.html#a3de0f0baf35f42aa4e77a90d427f2e11">Wt::WObject::addChild</a></div><div class="ttdeci">void addChild(std::unique_ptr&lt; WObject &gt; child)</div><div class="ttdoc">Add a child WObject whose lifetime is determined by this WObject.</div></div>
<div class="ttc" id="aclassWt_1_1WApplication_html"><div class="ttname"><a href="classWt_1_1WApplication.html">Wt::WApplication</a></div><div class="ttdoc">Represents an application instance for a single session.</div><div class="ttdef"><b>Definition:</b> WApplication.h:205</div></div>
<div class="ttc" id="aclassWt_1_1WApplication_html_a5231d54ed34982f4366058eb6440c8f7"><div class="ttname"><a href="classWt_1_1WApplication.html#a5231d54ed34982f4366058eb6440c8f7">Wt::WApplication::quit</a></div><div class="ttdeci">void quit()</div><div class="ttdoc">Quits the application.</div></div>
<div class="ttc" id="aclassWt_1_1WApplication_html_a27690e10fb1dffef9b688b5a6ecf26b0"><div class="ttname"><a href="classWt_1_1WApplication.html#a27690e10fb1dffef9b688b5a6ecf26b0">Wt::WApplication::instance</a></div><div class="ttdeci">static WApplication * instance()</div><div class="ttdoc">Returns the current application instance.</div></div>
<div class="ttc" id="aclassWt_1_1WMouseEvent_html"><div class="ttname"><a href="classWt_1_1WMouseEvent.html">Wt::WMouseEvent</a></div><div class="ttdoc">A class providing details for a mouse event.</div><div class="ttdef"><b>Definition:</b> WEvent.h:177</div></div>
<div class="ttc" id="aclassWt_1_1WText_html"><div class="ttname"><a href="classWt_1_1WText.html">Wt::WText</a></div><div class="ttdoc">A widget that renders (XHTML) text.</div><div class="ttdef"><b>Definition:</b> WText.h:91</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
